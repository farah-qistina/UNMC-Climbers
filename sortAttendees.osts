function main(workbook: ExcelScript.Workbook) {
    const maxMembers = 20; // Maximum total selected people
    const maxUnskilled = 10; // Maximum unskilled passengers

    // Get the worksheet named "Sheet1"
    let sheet = workbook.getWorksheet("Sheet1");
    if (!sheet) {
        console.log("Sheet1 not found.");
        return;
    }

    // Get the used range
    let usedRange = sheet.getUsedRange();
    if (!usedRange) {
        console.log("No data found in Sheet1.");
        return;
    }

    let values: (string | number | boolean)[][] = usedRange.getValues();

    // Find the index of relevant columns
    let headerRow = values[0] as string[]; // Assuming first row is the header
    let idIndex = headerRow.indexOf("Id");
    let nameIndex = headerRow.indexOf("Name1");
    let skillIndex = headerRow.indexOf("Do you know how to belay and tie an 8-figure knot?");
    let transportIndex = headerRow.indexOf("Means of Transportation");
    let mamakIndex = headerRow.indexOf("Will you be joining us for the post-climb mamak session?");

    if (idIndex === -1 || nameIndex === -1 || skillIndex === -1 || transportIndex === -1 || mamakIndex === -1) {
        console.log("One or more required columns not found in Sheet1.");
        return;
    }

    // Find where the second table starts
    let secondTableStart = -1;
    for (let i = 0; i < values.length; i++) {
        if (values[i][0] === "Name" && values[i][1] === "No. of Climbs") {
            secondTableStart = i + 1;
            break;
        }
    }

    if (secondTableStart === -1) {
        console.log("Second table (Climbs) not found.");
        return;
    }

    // Extract climb data into a dictionary, ensuring names are properly formatted
    let climbDict: { [key: string]: number } = {};
    for (let i = secondTableStart; i < values.length; i++) {
        let climbName = values[i][0]?.toString().trim();
        let climbCount = parseInt(values[i][1]?.toString() || "0");

        if (climbName && !isNaN(climbCount)) {
            let formattedClimbName = formatName(climbName); // Apply name formatting
            climbDict[formattedClimbName] = climbCount;
        }
    }

    // Initialize categories
    let drivers: string[][] = [];
    let selfTransport: string[][] = [];
    let passengers: string[][] = [];

    // Function to properly format names
    function formatName(name: string): string {
        return name
            .toLowerCase()
            .split(" ")
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ");
    }

    // Process each row (excluding header)
    for (let i = 1; i < secondTableStart - 2; i++) {
        let row = values[i];
        let id = row[idIndex]?.toString().trim();
        let name = row[nameIndex]?.toString().trim();
        let skill = row[skillIndex]?.toString().trim();
        let transport = row[transportIndex]?.toString().trim();
        let mamak = row[mamakIndex]?.toString().trim();

        if (!id || !name) continue; // Skip empty IDs or names

        let formattedName = formatName(name);
        skill = skill.toLowerCase() === "yes" ? "Yes" : "No";
        mamak = mamak.toLowerCase() === "yes" ? "Yes" : "No";
        let climbCount = climbDict[formattedName] ?? 0;

        let person: string[] = [id, formattedName, climbCount.toString(), skill];

        if (transport === "Carpool Driver") {
            drivers.push(person);
        } else if (transport === "Self-Transport") {
            selfTransport.push(person);
        } else {
            passengers.push(person);
        }
    }

    let totalPeople = passengers.length + drivers.length + selfTransport.length;
    let y = maxMembers - (drivers.length + selfTransport.length);

    // If more than maxMembers, apply selection process
    let selectedPassengers: string[][] = [];
    let calculations: string[][] = [
        ["Passengers Sorted by Climbs:", "", "", "", "", "Passengers Sorted by Skill:", "", "", "", "", "Top " + maxUnskilled + ":", "", "", "", "", "Remaining Passengers Sorted by ID:", "", "", "", "", "All Passengers Sorted:", "", "", "", "", y + " Selected Passengers:"],
        ["ID", "Name", "Climbs", "Skill", "", "ID", "Name", "Climbs", "Skill", "", "ID", "Name", "Climbs", "Skill", "", "ID", "Name", "Climbs", "Skill", "", "ID", "Name", "Climbs", "Skill", "", "ID", "Name", "Climbs", "Skill"]
    ];

    if (totalPeople > maxMembers) {

        // Step 1: Sort passengers by climbs (ascending), then by ID (ascending)
        let sortedByClimbs = passengers.sort((a, b) => {
            let climbDiff = parseInt(a[2]) - parseInt(b[2]); // Ascending order
            if (climbDiff !== 0) return climbDiff;
            return parseInt(a[0]) - parseInt(b[0]); // Sort by ID if climbs are equal
        });

        // Step 2: Sort by skill ("No" first), keeping climbs in ascending order
        let sortedBySkill = [...sortedByClimbs].sort((a, b) => {
            if (a[3] === "No" && b[3] !== "No") return -1;
            if (a[3] !== "No" && b[3] === "No") return 1;
            return parseInt(a[2]) - parseInt(b[2]); // Keep climbs in ascending order
        });

        // Step 3: Select top `maxUnskilled` from `sortedBySkill`
        let topUnskilled = sortedBySkill.slice(0, maxUnskilled);

        // Step 4: Remaining passengers sorted by ID
        let remainingPassengers = sortedBySkill.slice(maxUnskilled).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));

        // Step 5: Merge `topUnskilled` and `remainingPassengers`
        let allSortedPassengers = [...topUnskilled, ...remainingPassengers];

        // Step 6: Select the top `y` from `allSortedPassengers`
        selectedPassengers = allSortedPassengers.slice(0, y);
        passengers = selectedPassengers;

        // Ensure lists are side by side
        let maxRows = Math.max(sortedByClimbs.length, sortedBySkill.length, topUnskilled.length, remainingPassengers.length, allSortedPassengers.length, passengers.length);
        for (let i = 0; i < maxRows; i++) {
            calculations.push([
                i < sortedByClimbs.length ? sortedByClimbs[i][0] : "", i < sortedByClimbs.length ? sortedByClimbs[i][1] : "", i < sortedByClimbs.length ? sortedByClimbs[i][2] : "", i < sortedByClimbs.length ? sortedByClimbs[i][3] : "", "",
                i < sortedBySkill.length ? sortedBySkill[i][0] : "", i < sortedBySkill.length ? sortedBySkill[i][1] : "", i < sortedBySkill.length ? sortedBySkill[i][2] : "", i < sortedBySkill.length ? sortedBySkill[i][3] : "", "",
                i < topUnskilled.length ? topUnskilled[i][0] : "", i < topUnskilled.length ? topUnskilled[i][1] : "", i < topUnskilled.length ? topUnskilled[i][2] : "", i < topUnskilled.length ? topUnskilled[i][3] : "", "",
                i < remainingPassengers.length ? remainingPassengers[i][0] : "", i < remainingPassengers.length ? remainingPassengers[i][1] : "", i < remainingPassengers.length ? remainingPassengers[i][2] : "", i < remainingPassengers.length ? remainingPassengers[i][3] : "", "",
                i < allSortedPassengers.length ? allSortedPassengers[i][0] : "", i < allSortedPassengers.length ? allSortedPassengers[i][1] : "", i < allSortedPassengers.length ? allSortedPassengers[i][2] : "", i < allSortedPassengers.length ? allSortedPassengers[i][3] : "", "",
                i < passengers.length ? passengers[i][0] : "", i < passengers.length ? passengers[i][1] : "", i < passengers.length ? passengers[i][2] : "", i < passengers.length ? passengers[i][3] : ""
            ]);
        }

        let calcSheet = workbook.getWorksheet("Calculations") ?? workbook.addWorksheet("Calculations");
        calcSheet.getUsedRange()?.clear();
        // Ensure all rows in 'calculations' have the same number of columns
        let maxCols = Math.max(...calculations.map(row => row.length));
        calculations = calculations.map(row => [...row, ...Array(maxCols - row.length).fill("")]);

        // Set calculations values
        let calcRange = calcSheet.getRangeByIndexes(0, 0, calculations.length, calculations[0].length);
        calcRange.setValues(calculations);

        // Ensure all text and numbers are left-aligned
        calcRange.getFormat().setHorizontalAlignment("Left");
    }

    // Ensure "Attendees" sheet exists, or create it
    let attendeesSheet = workbook.getWorksheet("Attendees") ?? workbook.addWorksheet("Attendees");
    attendeesSheet.getUsedRange()?.clear(); // Clear previous contents

    // Define the first table (Main Attendee List) with "Cancelled" column added
    let attendeesTable: string[][] = [
        ["Name", "Arrived", "Sent Out", "Cancelled"], // Updated header
        ["Passengers", "", "", ""],
        ...passengers.map(p => [p[1], "", "", ""]), // Adding empty column for "Cancelled"
        ["", "", "", ""], ["Drivers", "", "", ""],
        ...drivers.map(p => [p[1], "", "", ""]), ["", "", "", ""], ["", "", "", ""], ["", "", "", ""],// Adding empty column for "Cancelled"
        ["", "", "", ""], ["Self-Transport", "", "", ""],
        ...selfTransport.map(p => [p[1], "", "", ""]), // Adding empty column for "Cancelled"
        ["", "", "", ""], ["Committee", "", "", ""],
    ];

    // Define the second table (Driver and Passenger) with a one-column gap
    let transportTable: string[][] = [
        ["Driver", "Passenger"],
    ];

    // Set all columns in the "Attendees" sheet to a fixed width of 200px
    let totalColumns = attendeesTable[0].length + transportTable[0].length + 1; // Includes both tables
    for (let col = 0; col < totalColumns; col++) {
        attendeesSheet.getCell(0, col).getFormat().setColumnWidth(100);
    }

    // Set values in the "Attendees" sheet
    attendeesSheet.getRangeByIndexes(0, 0, attendeesTable.length, attendeesTable[0].length).setValues(attendeesTable);
    attendeesSheet.getRangeByIndexes(0, 5, transportTable.length, transportTable[0].length).setValues(transportTable); // Placing the second table 1 column to the right

    // Apply Bold Formatting to Specific Headers
    function applyBoldFormatting(range: ExcelScript.Range) {
        range.getFormat().getFont().setBold(true);
    }

    // Apply Background Color to Differentiate Sections
    function applyBackgroundColor(range: ExcelScript.Range, color: string) {
        range.getFormat().getFill().setColor(color);
    }

    // Define colors
    let headerColor = "#FCE4D6"; // Light orange for headers
    let passengerColor = "#FFF2CC"; // Light yellow for Passengers
    let driverColor = "#E2EFDA"; // Light green for Drivers
    let selfTransportColor = "#DDEBF7"; // Light blue for Self-Transport
    let committeeColor = "#D9E1F2"; // Light purple for Committee

    // Apply bold formatting to headers
    applyBoldFormatting(attendeesSheet.getRangeByIndexes(0, 0, 1, 4)); // "Name", "Arrived", "Sent Out", "Cancelled"
    applyBoldFormatting(attendeesSheet.getRangeByIndexes(0, 5, 1, 2)); // "Driver", "Passenger"

    // Apply background color to headers
    applyBackgroundColor(attendeesSheet.getRangeByIndexes(0, 0, 1, 4), headerColor); // "Name", "Arrived", "Sent Out", "Cancelled"
    applyBackgroundColor(attendeesSheet.getRangeByIndexes(0, 5, 1, 2), headerColor); // "Driver", "Passenger"

    // Apply bold formatting and colors to section titles
    let titleRows = {
        passengers: 1,
        drivers: passengers.length + 3,
        selfTransport: passengers.length + drivers.length + 8,
        committee: passengers.length + drivers.length + selfTransport.length + 10
    };

    // Apply colors to section titles
    applyBoldFormatting(attendeesSheet.getRangeByIndexes(titleRows.passengers, 0, 1, 4));
    applyBoldFormatting(attendeesSheet.getRangeByIndexes(titleRows.drivers, 0, 1, 4));
    applyBoldFormatting(attendeesSheet.getRangeByIndexes(titleRows.selfTransport, 0, 1, 4));
    applyBoldFormatting(attendeesSheet.getRangeByIndexes(titleRows.committee, 0, 1, 4));

    applyBackgroundColor(attendeesSheet.getRangeByIndexes(titleRows.passengers, 0, 1, 4), passengerColor);
    applyBackgroundColor(attendeesSheet.getRangeByIndexes(titleRows.drivers, 0, 1, 4), driverColor);
    applyBackgroundColor(attendeesSheet.getRangeByIndexes(titleRows.selfTransport, 0, 1, 4), selfTransportColor);
    applyBackgroundColor(attendeesSheet.getRangeByIndexes(titleRows.committee, 0, 1, 4), committeeColor);
}
